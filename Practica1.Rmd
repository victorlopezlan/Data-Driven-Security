---
title: "Práctica 1"
author: "Oriol, Víctor, Miriam"
date: "2025-12-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(error = F)
knitr::opts_chunk$set(message = F)
```

## **Ejercicio 1**

**De las siguientes preguntas, clasifica cada una como descriptiva, exploratoria, inferencia, predictiva o causal, y razona brevemente (una frase) el porqué:**

**1. Dado un registro de vehículos que circulan por una autopista, disponemos de su marca y modelo, país de matriculación, y tipo de vehículo (por número de ruedas). Con tal de ajustar precios de los peajes, ¿Cuántos vehículos tenemos por tipo? ¿Cuál es el tipo más frecuente? ¿De qué países tenemos más vehículos?**

```         
Descriptiva, ya que estamos buscando estadíticas del total de vehículos según sus características para hacer un ajuste del precio de los peajes.
```

**2. Dado un registro de visualizaciones de un servicio de video-on-demand, donde disponemos de los datos del usuario, de la película seleccionada, fecha de visualización y categoría de la película, queremos saber ¿Hay alguna preferencia en cuanto a género literario según los usuarios y su rango de edad?**

```         
Exploratoria, ya que se está relacionando el rango de edad del usuario con la preferencia del género cinematográfico.
```

**3. Dado un registro de peticiones a un sitio web, vemos que las peticiones que provienen de una red de telefonía concreta acostumbran a ser incorrectas y provocarnos errores de servicio. ¿Podemos determinar si en el futuro, los próximos mensajes de esa red seguirán dando problemas? ¿Hemos notado el mismo efecto en otras redes de telefonía?**

```         
Predictiva, ya que intentamos predecir un comportamiento futuro a partir de un registro de peticiones ya realizadas a un sitio web.
```

**4. Dado los registros de usuarios de un servicio de compras por internet, los usuarios pueden agruparse por preferencias de productos comprados. Queremos saber si ¿Es posible que, dado un usuario al azar y según su historial, pueda ser directamente asignado a un o diversos grupos?**

```         
Predictiva, porque a partir de los datos que tenemos del historial del usuario, le estamos asignando a un o diversos grupos.
```

## **Ejercicio 2**
**El segundo apartado de la práctica consiste en el análisis de un fichero de registro de peticiones HTTP, que debéis descargar el fichero adjunto: epa-http.zip, cargar en R, y realizar un análisis**

**Se recomienda tener cierto nivel de familiaridad y al alcance los cheatsheet de las distintas librerías mencionadas en las sesiones de teoría para un análisis más fácil:**

**- readr**

**- stringr**

**Alternativamente, recordad que podéis consultar la sección de ayuda de RStudio y buscar en la documentación los parámetros, así como ejemplos de uso (al final de cada página de documentación) para las funciones (escribiendo ?<nombre-funcion> o presionando F1 sobre el nombre de la función.** 

**Para las siguientes preguntas se requiere usar R. Indica en este documento para cada pregunta el resultado obtenido, describiendo a grandes rasgos el procedimiento seguido para la obtención de la respuesta, justificando cada decisión tomada a la hora de manipular los datos (descartar, agrupar, transformar, etc).**

**Asegúrate de entregar también el código en un fichero aparte, para poder ejecutarse directamente en un terminal limpio de R.**

```{r carrega_llibreries}
library(readr)
library(dplyr)
library(stringr)
```

Limpiamos los datos e indicamos el tipo de dato de cada campo:

- Mediante la librería 'stringr' impiamos el símbolo " que se encuentra al inicio de cada valor del campo Tipo y el símbolo " que se encuentra al final de cada valor del campo Protocolo.

- Campo ResponseCode lo cambiamos al tipo de dato factor, ya que son "etiquetas", no son valores númericos.

- Campo Bytes lo cambiamos al tipo de dato integer, ya que si que nos interesa tratarlo como valor númerico.

```{r carrega_dades}
epa_http <- read_table("epa-http.csv", col_names = FALSE, show_col_types = F)
colnames(epa_http) <- c("IP", "Timestamp", "Tipo", "URL", "Protocolo", "ResponseCode", "Bytes")
# Cambiamos el tipo de la columna ResponseCode a factor 
epa_http$ResponseCode <- as.factor(epa_http$ResponseCode)
# Cambiamos el tipo de la columna Bytes a integer
epa_http$Bytes <- as.integer(epa_http$Bytes)
#Limpiamos el simbolo " al inicio del campo Tipo con libreria stringr
epa_http$Tipo <- str_remove(epa_http$Tipo, '^"')
#Alternativa para limpiar " del inicio del campo Tipo
#epa_http$Tipo <- sub('^"', '', epa_http$Tipo)
#Limpiamos el simbolo " del final del campo Protocolo con libreria stringr
epa_http$Protocolo <- str_remove(epa_http$Protocolo, '"$')
```

```{r show_dades, comment = NA}
knitr::kable(
  head(epa_http),
  caption = "Primeras 6 filas del conjunto de datos:"
)
```

Utilizando libreria DT podemos mostrar todo el conjunto de datos, incluyendo un buscador:

*Hay que tener en cuenta el consumo que conlleva y el volumen de datos con el que estemos trabajando*

```{r show_dades3, comment = NA}
DT::datatable(
  epa_http,
  options = list(
    pageLength = 10,
    scrollX = TRUE,
    caption = "Todo el conjunto de datos:"
  )
)
```

#### **Pregunta 1**
**Una vez cargado el Dataset a analizar, comprobando que se cargan las IPs, el Timestamp, la Petición (Tipo, URL y Protocolo), Código de respuesta, y Bytes de reply.**

**1. Cuales son las dimensiones del dataset cargado (número de filas y columnas)**

Número filas:
```{r Apartado1.1, comment = NA}
cat(nrow(epa_http))
```

Justificación: utilizamos *nrow* para obtener el número de filas.

Número columnas:  
```{r Apartado1.2, comment = NA}
cat(ncol(epa_http))
```

Justificación: Utilizamos *ncol* para obtener el número de columnas.

**2. Valor medio de la columna Bytes**
```{r mediaBytes, comment = NA}
cat(mean(epa_http$Bytes, na.rm = T))
```

Justificación: Utilizamos *mean* para calcular el valor medio de la columna Bytes, indicamos que se ignores valores NA.

#### **Pregunta 2**
**De las diferentes IPs de origen accediendo al servidor, ¿cuantas pertenecen a una IP claramente educativa (que contenga ".edu")?**
```{r Apartado2, comment = NA}
cat(sum(grepl(".edu", epa_http$IP)))

```

Justificación: Utilizamos *grepl* para filtrar peticiones que contengan ".edu" en el campo IP, obtenemos el total de peticiones que cumplen este filtro.

#### **Pregunta 3**
**De todas las peticiones recibidas por el servidor cual es la hora en la que hay mayor volumen de peticiones HTTP de tipo "GET"?**

Justificación: Generamos un nuevo dataframe donde únicamente estén las filas con GET, añadimos una nueva columna *Hora* con las diferentes horas del día que se encuentran en la columna Timestamp y agrupamos por horas. Creamos un dataframe con únicamente 2 columnas: Hora (0-23) y número de peticiones por hora; si ordenamos en orden descendente y solo mostramos la primera fila, tenemos la hora en la que mayor volumen hay:

```{r Apartado3, comment = NA}
# Creamos un nuevo dataframe donde solo estan las filas con GET
epa_get <- epa_http[epa_http$Tipo == "GET", ]

#Cogemos en nuevo dataframe y le creamos una nueva columna llamada hora con el valor correspondiente del Timestamp
epa_get <- epa_get %>%
  mutate(
    Hora = sub("^\\[|\\]$", "", Timestamp),  # quita [ ]
    Hora = sapply(strsplit(Hora, ":"), `[`, 2)
  )

#Hacemos el conteo de cuantas veces aparece cada una de las horas:
# Para ello creamos un dataframe nuevo con solo dos columnas, el valor de las horas [0-23] y el número de veces que aparece cada hora
conteo_horas <- epa_get %>%count(Hora)

#Mostramos solo la primera fila, ya que estamos filtrando de manera descendente la columna que contiene el número de veces que aparece cada hora
hora_max <- conteo_horas %>%
  arrange(desc(n)) %>%  # Orden descendente
  slice(1) %>%                  # Solo la primera fila
  pull(Hora)                     # Extrae la columna "Hora"

cat(hora_max)

#Tabla sencilla mostrando las 5 horas del dia con mayor numero de peticiones
knitr::kable(
  conteo_horas %>%
    arrange(desc(n)) %>%  # Orden descendente por la columna n
    slice(1:5),             # Solo la primera fila
  caption = "Mostramos las 5 horas del día con mayor número de peticiones:"
)

```

Probamos *barplot* para generar un gráfico de barras que nos informe del número de peticiones HTTP GET por hora:

```{r Apartado3.2, comment = NA}
# Ordenamos horas
conteo_horas <- conteo_horas[order(conteo_horas$Hora), ]

#Generamos gráfico de barras
barplot(
  height = conteo_horas$n,
  names.arg = conteo_horas$Hora,
  col = "steelblue",
  xlab = "Hora del día",
  ylab = "Número de peticiones HTTP GET",
  main = "Peticiones HTTP GET por hora"
)
```

#### **Pregunta 4**
**De las peticiones hechas por instituciones educativas (.edu), ¿Cuantos bytes en total se han transmitido, en peticiones de descarga de ficheros de texto ".txt"?**

El número total de Bytes que se han transmitido en las peticiones de descarga de ficheros de texto son:
```{r Apartado4, comment = NA}

#filtramos solo las filas que contienen la cadena de texto ".edu" en la columna de IP
epa_edu <- epa_http[grepl("\\.edu", epa_http$IP), ]

#filtramos solo las filas que contienen un fichero de descarga .txt
epa_edu <- epa_edu[grepl("\\.txt", epa_edu$URL), ]

#Hacemos la suma de la columna de Bytes, ignorando aquellos que tienen valor de NA
cat(sum(epa_edu$Bytes, na.rm = T))

```

Justificación: De las 6539 peticiones que contienen ".edu" en el campo IP, filtramos de igual forma aquellas que tienen una extensión ".txt" en el campo URL. Calculamos el total sumando las peticiones que cumplen con estas condiciones.

#### **Pregunta 5**
**Si separamos la petición en 3 partes (Tipo, URL, Protocolo), usando str_split y el separador " " (espacio), ¿cuantas peticiones buscan directamente la URL = "/"?**

El número total de peticiones que buscan directamente la URL = \"/\" son:

```{r Apartado5, comment = NA}
#Hacemos la suma de las filas cuyo URL tenga de valor "/"
cat(sum(epa_http$URL == "/", na.rm = T))
```

Justificación: Hemos calculado el total de filas donde el campo URL contenga el símbolo /

#### **Pregunta 6**
**Aprovechando que hemos separado la petición en 3 partes (Tipo, URL, Protocolo) ¿Cuantas peticiones NO tienen como protocolo "HTTP/0.2"?**

Peticiones que NO tienen como protocolo HTTP/0.2:

```{r Apartado6, comment = NA}
#Hacemos la suma de las filas cuyo Protocolo NO tenga de valor HTTP/0.2 
cat(sum(epa_http$Protocolo != "HTTP/0.2", na.rm = T))
```
Justificación: Hemos calculado el total de filas que NO tienen como valor HTTP/0.2